---
title: (17) 구조체 (2)
excerpt: 구조체의 복사 및 메모리 정렬에 대해서 알아보자
categories: 
  - 게임서버 과정
permalink: /game-server-curriculum/:title
toc: true
toc_sticky: true
typora-root-url: ../../
---

### 1. 구조체 복사 방식

**구조체의 크기에 따라 복사 방식이 달라집니다.**

1. **작은 구조체**는 멤버별 대입 연산(예: `operator=`)을 통해 복사됩니다.
2. **큰 구조체**는 효율적인 복사를 위해 `rep movs` 명령어를 활용할 수 있습니다. 일반적으로 CPU 아키텍처와 최적화 수준에 따라 4바이트 또는 8바이트 단위로 복사가 이루어집니다.
3. 64비트 컴파일러에서는 `rep movs`를 사용하여 8바이트 단위로 복사하는 경우가 많습니다.
   - 그러나 "64비트 컴파일러가 `rep movs`를 이용해 **1바이트씩** 복사한다"는 표현은 잘못되었습니다.
   - 실제로는 CPU의 명령어 최적화에 따라 가능한 경우 **최대 8바이트** 단위로 복사됩니다.

### 2. 멀티스레드 환경에서 `rep movs` 사용 시 원자성 문제

멀티스레드 환경에서 `rep movs`는 원자성을 보장하지 않습니다.

1. `movs` 명령어는 단일 실행 단위에서는 원자성을 가지지만, `rep movs`는 여러 개의 `movs` 명령을 반복 실행하므로 원자성이 깨질 수 있습니다.
2. 비원자적 데이터 복사 문제
   - `rep movs` 수행 중 다른 스레드가 구조체의 일부를 읽거나 쓰면, 데이터가 불완전한 상태가 될 수 있습니다.
   - 예를 들어, `rep movs`가 8바이트 단위로 복사하는 중간에 다른 스레드가 개입하면, **변경 전**, **변경 중**, **변경 후**라는 세 가지 상태가 존재할 수 있습니다.
3. 해결책
   - 구조체 복사가 멀티스레드 환경에서 안전하게 이루어지려면 **락(lock)** 또는 **원자적 연산(atomic operation)** 을 사용해야 합니다.
   - C++에서는 `std::atomic`을 활용하거나, **메모리 배리어(memory barrier)** 및 Interlocked 함수 또는 Lock을 함께 사용해 동기화할 수도 있습니다.

### 3. 함수에서 구조체를 지역변수로 반환할 때의 문제

함수에서 구조체를 반환할 때, 불필요한 복사가 발생할 가능성이 있습니다.

1. 컴파일러의 최적화
   - 대부분의 현대 컴파일러(특히 Clang, GCC, MSVC)는 **Return Value Optimization(RVO)** 를 적용하여 불필요한 복사를 줄입니다.
   - 즉, 지역 변수의 구조체가 직접 호출자의 메모리 공간에 저장되므로 **추가적인 복사가 생기지 않을 수도 있습니다.**
2. 복사가 발생하는 경우
   - RVO가 적용되지 않는 경우, 반환된 구조체는 호출자의 메모리에 복사됩니다.
   - 크기가 큰 구조체를 반환하면 **복사 비용이 증가**하므로, **포인터** 또는 **참조 반환**을 고려해야 합니다.
