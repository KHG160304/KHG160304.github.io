---
title: (4) 스택 메모리
excerpt: 스택 메모리란 무엇이며 작동하는 원리에 대해서 알아보자
categories: 
  - 게임서버 과정
permalink: /game-server-curriculum/:title
toc: true
toc_sticky: true
typora-root-url: ../../
---

## 스택 메모리란?

스택 메모리는 어떤 함수가 실행 중인 상태라고 했을 때, 이 함수의 실행 흐름과 관련된 데이터 또는 상태 값을 저장하기 위한 용도로 메모리에 미리 확보된 공간입니다. 

현재 실행 중인 함수를 종료하지 않은 상태에서 새로운 함수를 계속 호출할 때마다 함수를 위한 공간이 계속 메모리에 생성되며, 이 형태가 마치 블록이 차곡차곡 쌓이는 것과 같은 형태를 띠고 있으므로 스택 메모리라고 부른다.

### 스택 메모리의 생명주기란?

실행 중인 함수의 생명주기와 마찬가지로 해당 함수의 상태 값을 저장하는 스택 메모리 공간도 동일한 생명주기를 가집니다.
스택 메모리의 공간의 시작과 끝을 가리키는 레지스터에는 ebp와 esp 레지스터가 사용됩니다.

#### `함수 A` 에서 `함수 B`를 호출하는 경우 

ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ <----- 현재 esp가 가리키는 위치
함수 B의 스택 메모리 공간 (4)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ <----- 현재 ebp가 가리키는 위치
backup 함수 A 의 ebp (3)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
backup 함수 A의 실행 흐름으로 되돌아갈 수 있는 명령어 주소 (2)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ
함수 A의 스택 메모리 공간 (1)
ㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡㅡ

[스택 메모리의 모습]



1. 함수 A의 실행 흐름으로 되돌아갈 수 있는 명령어 주소를 스택 메모리에 push 합니다.
2. 함수 A의 ebp를 스택 메모리에 push 합니다.
3. 현재 esp 의 값을 ebp에 복사합니다.
4. 함수 B에서 필요로 하는 만큼 스택 메모리에 공간을 확보합니다.

#### ebp 레지스터의 오염 그리고 스택 메모리가 깨지는 경우

ebp 레지스터의 역할은 함수 main이 있고, main에서 호출한 현재 실행 중인 함수 A가 있으면 스택 메모리에서 함수 A를 위해 확보한 공간의 시작 주소를 저장하고 있는 역할을 합니다. 그런데 함수 A의 코드에서 스택 메모리에 저장된 backup된 함수 main의 실행 흐름으로 되돌아갈 수 있는 명령어 주소를 조작해버린 경우, 함수 A가 종료되는 시점에 **ebp 레지스터에 잘못된 값이 설정되어** 함수 main를 위한 **스택 메모리 공간의 위치가 바뀌어** 버릴 수 있습니다. 공간이 바뀌면 **함수 main의 코드가 실행되면서 바뀐(잘못된) 메모리 공간에 저장된 값에 접근**하여 데이터를 읽고 쓰는 상황이 충분히 발생할 수 있게 되는 것입니다. 정말 심각한 문제가 아닐 수 없습니다.

위의 문제 상황을 강제로 발생 시키는 예제코드입니다.

~~~cpp
#include <stdio.h>

int A(void)
{
	int* main_ebp = (int*)&main_ebp;
    //security_cookie 보안 옵션이 활성화된 경우, sizeof(int) * 2 아닌 경우 sizeof(int)를 사용
	main_ebp = (int*)(((int)main_ebp) + sizeof(int) * 2);
	*main_ebp = 0;
	return 1;
}

int main(void) 
{
	int number = 15;
	A();
	printf("%d", number);

	return 0;
}
~~~

위의 예제코드를 Visual C++ x86-32bit 시스템에서 작동하도록 32bit 프로그램으로 컴파일하고 실행하면 문제가 발생하는 것을 발견할 수 있습니다. (참고 x86-64bit 시스템은 rbp 레지스터를 사용하여 스택 메모리 계산을 하지 않기 때문에, rbp 레지스터를 오염 시켜서 스택을 깨는 행위는 불가능합니다.) 

A 함수 호출이 종료된 이후 main 함수에서 number 변수에 접근할 때 ebp - 4 이런 식으로 ebp 레지스터에 저장된 주소 값 기준으로 얼마나 떨어진 위치의 메모리에 접근해야 하는지를 상대적으로 계산합니다. 현재 ebp 레지스터에는 주소 0번지를 가리키고 있다. 0 ~ 64KB 사이에 해당하는 주소의 메모리 공간은 Windows OS에서 메모리 읽기 쓰기 같은 접근이 불가능하게 관리되고 있습니다. 위 코드에서 number라는 변수에 저장된 값을 읽으려고 하는데, 주소 4번지에서 offset -4 만큼 떨어진 주소에 접근하려고 시도하였으나 crash가 발생하는 상황이 연출되었습니다.

위의 상황은 결과적으로 프로그램이 crash를 발생시켰기 때문에 에러를 발견한 상황이지만 만약 crash가 발생하지 않고, 코드가 정상적으로 실행되는 상황이 온다면, 프로그램이 완전 엉망이 되고, 문제가 어디서 발생하였는지 찾는 것도 거의 불가능에 가까워지게 됩니다. 정말 치명적인 상황입니다.
