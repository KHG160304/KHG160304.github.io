---
title: (8) 조건문(Control Flow)
excerpt: 조건문에 대해서 알아보자.
categories: 
  - 게임서버 과정
permalink: /game-server-curriculum/:title
toc: true
toc_sticky: true
typora-root-url: ../../
---

[toc]

## 조건문이란

조건문은 특정 구문을 평가하여 결과 값으로 참 또는 거짓을 판별할 수 있는 구문입니다.
기본적으로 구분의 결과 값이 0 이면 거짓, 0 이외의 값은 참으로 판별하며, 관계 연산자를 통해서 참, 거짓이 되는 값을 지정할 수 있습니다.

## if else 조건문

~~~cpp
int x = 0;
if (x)
{
    printf("조건문이 참인 경우 실행되는 코드\n");
}
else 
{
    printf("조건문이 거짓인 경우 실행되는 코드\n");
}
~~~

if 조건문에서 x 값을 평가합니다. x 값이 0 임으로 해당 조건문은 거짓으로 평가되어, else 코드블럭에 작성된 코드를 실행합니다.

~~~cpp
if (x == 0)
{
    printf("x가 0인 경우 실행되는 코드\n");
}
else if (x != 1)
{
    printf("x가 1이 아닌 경우 실행되는 코드\n");
}
else
{
    printf("위의 두 조건이 모두 거짓인 경우 실행되는 코드\n");
}
~~~

위의 조건문은 관계 연산자를 사용하여 검사하는 변수가 특정 값을 만족하는지 판별하여 코드를 실행하고 있습니다. 위 처럼 if else 구문은 중첩하여 나열할 수 있으며, 중첩할 수 있는 수의 제한은 없습니다. 위에서부터 아래로 조건문을 하나 씩 평가합니다. 참이 되는 조건을 발견하면, 조건문 평가를 멈추고 해당 조건문의 코드블럭에 작성된 코드를 실행합니다. 그리고 나열된 if else 구문을 벗어납니다.

### if else 조건문 성능 최적화 기법

1. **`AND`** 논리 연산자를 통해 **`여러 조건을 평가`**하는 경우
   거짓이 될 확률이 높은 조건 먼저 작성합니다. 

   > AND 논리 연산자의 경우 거짓이 되는 조건을 발견하는 즉시, 해당 if 조건문의 평가를 바로 중지하고 다음 코드를 평가하기 위해 이동합니다. 이것을 short circit 이라고 합니다.

2. **`OR`** 논리 연산자를 통해 **`여러 조건을 평가`**하는 경우
   참이 될 확률이 높은 조건을 먼저 작성합니다.

   > OR 논리 연산자의 경우 참이 되는 조건을 발견하는 즉시, 해당 if 조건문의 평가를 중지하고 해당 if 조건문 아래에 작성된 코드블럭을 실행합니다.

## switch case 조건문

switch case는 특정 변수의 값을 검사해서, case 라벨에 작성된 데이터와 일치 여부를 비교해서 일치하면, 해당 case에 작성된 명령어 구문을 실행하는 조건문입니다.

~~~cpp
int month = 12;
switch(month)
{
    case 1:
        break;
        .
		.
        .
    case 9:
        break;
    case 10:
        break;
    case 11:
        break;
    case 12:
        break;
}
~~~

### switch case 특징

1. case 라벨에는 정수형 상수만 작성할 수 있습니다.
   > char, short, int, long, long long, enum 이 있습니다.

   > ※ case 라벨은 상수임으로 컴파일 타임 최적화가 가능합니다.

2. 잘 작성된 switch case 문은 점프 테이블을 활용하는 어셈블리 코드가 생성됩니다.

3. 최적화가 안된 switch case 조건문은 일반 if else 조건문과 동일한 어셈블리 코드가 생성됩니다.

#### 최적화 가능한 switch case 조건문 특징

1. case 문의 개수가 일정 개수 이상을 충족하여야 합니다.
   (ex. 4개 또는 6개 이상, 어떤 어셈블리 코드가 생성되는지 항상 확인해 보시오)

2. 나열되는 case 문이 정수 값이 오름차순으로 정렬되어야 합니다.

   > 순서대로 1, 2, 3, 4, 5 ... 또는 1, 3, 7, 10, 12, 19, 23과 같이 숫자의 나열이 오름차순으로 정렬되어야 합니다.
   > 정렬된 case 라벨 정수 값들의 차가 일정하지 않아도 상관없습니다.

#### 최적화된 switch case 어셈블리 코드 동작 원리

~~~cpp
int x = 4;
switch(x)
{
    case 1: printf("1"); break;
    case 2: printf("2"); break;
    case 3: printf("3"); break;
    case 4: printf("4"); break;
}
~~~

1. case 별로 실행될 명령어의 시작 주소들이 나열된 점프 테이블(배열)이 생성됩니다.
2. x - 1 (첫번째 case 라벨)의 결과 값이 점프 테이블(배열)에서 실행할 명령어가 저장된 인덱스가 됩니다.
3. 점프 테이블 시작 주소 + (인덱스 * (OS가 32비트? 4 : 8 )) 는 실행할 명령 코드의 메모리 주소 값이 계산된다.
4. 해당 메모리로 이동하여 명령을 실행합니다.



