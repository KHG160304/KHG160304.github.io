---
title: (18) 구조체 (3)
excerpt: 구조체 패딩과 메모리 정렬에 대해서 알아보자
categories: 
  - 게임서버 과정
permalink: /game-server-curriculum/:title
toc: true
toc_sticky: true
typora-root-url: ../../
---

### 1️⃣ 구조체 패딩과 메모리 정렬

패딩은 CPU의 **메모리 정렬(memory alignment)** 원칙에 따라 발생합니다.

1. CPU는 데이터를 빠르게 읽기 위해 **2ⁿ 바이트(예: 4바이트, 8바이트) 단위**로 정렬된 주소에서 읽는 것이 효율적입니다.
2. 구조체에서 **작은 자료형을 먼저 배치하고 큰 자료형을 나중에 배치하면 패딩이 발생합니다.**
3. **예제**

```
struct stData {
    char a;   // 1바이트
    int b;    // 4바이트 (정렬을 위해 패딩 추가)
};
```

이 경우, `char a`는 1바이트만 사용하지만, `int b`가 4바이트 정렬을 필요로 하므로 **추가적인 패딩(3바이트)이 발생**하여 전체 크기가 **8바이트**가 됩니다.

**최적화된 구조체 배치:**

```
struct stOptimized {
    int b;   // 4바이트 (먼저 배치)
    char a;  // 1바이트
    // 패딩 3바이트 (불가피하지만 최소화됨)
};
```

이렇게 하면 CPU가 한 번에 4바이트 또는 8바이트 단위로 읽고 쓸 수 있어 성능이 향상됩니다.

---

### 2️⃣ **구조체 정렬의 기본 원칙**

1. **구조체는 가장 큰 멤버의 크기와 동일한 정렬 기준(alignment)을 따릅니다.**
   - 예를 들어, 구조체 멤버 중 `__int64`(8바이트)가 가장 크다면, 구조체는 **8바이트 경계**(8의 배수 주소)에 정렬됩니다.
2. **구조체의 시작 주소가 정해지면, 개별 멤버들도 정렬 규칙을 따릅니다.**
   - 멤버 변수는 **자신의 크기 또는 구조체의 정렬 기준(가장 큰 멤버의 크기)** 중 작은 값을 기준으로 정렬됩니다.
   - 멤버 사이에 패딩(Padding)이 추가되어 정렬을 맞추게 됩니다.
3. **구조체 전체 크기는 모든 멤버의 크기 + 패딩을 합한 값입니다.**
   - 최종적으로 구조체 크기는 **가장 큰 멤버의 크기**의 배수가 됩니다.
   - 즉, 구조체 크기는 **"가장 큰 멤버의 크기"의 배수로 정렬**됩니다.

------

### 3️⃣ **메모리 정렬이 어긋날 경우 성능 저하 발생**

1. **런타임에서는 반드시 정렬된 주소에 할당되지 않을 수도 있습니다.**
   - 컴파일러는 **정렬 규칙을 적용하여 구조체를 배치하지만**,
     실제 메모리 할당(Heap, Stack)에서는 **정렬되지 않은 주소에 배치될 가능성**이 있습니다.
   - 특히 **동적 할당(Heap)** 시, 운영체제가 제공하는 메모리 주소가 예상과 다를 수 있음.
2. **구조체가 8바이트 경계가 아닌 4바이트 경계에서 시작하면 문제가 발생할 수 있습니다.**
   - 예를 들어, **8바이트 정렬을 기대했는데, 4바이트 정렬이 되면** 모든 멤버의 주소가 4바이트 밀려버림.
   - 이로 인해 **CPU가 데이터를 두 번 나누어 읽어야 하므로 성능 저하 발생.**

------

### 4️⃣ **CPU의 메모리 접근 방식**

1. **CPU는 메모리를 2^n 크기 단위로 접근합니다.**

   - 예를 들어, x86/x64 아키텍처에서는 **32비트(4바이트) 또는 64비트(8바이트) 단위**로 데이터를 읽음.

2. **8바이트 데이터가 4의 경계에 배치되면, CPU는 두 번의 메모리 접근이 필요함.**

   - `movq`(64비트 이동 명령어) 같은 경우, **8바이트 정렬된 주소에서 한 번에 데이터를 읽음.**

   - **그러나 4바이트 정렬된 주소에 8바이트 데이터를 저장하면, 두 번 읽어야 함!**

   - 예를 들어, `int64_t`가 0x1004 에 배치되면:
     1. CPU는 **0x1000~0x1003(첫 번째 메모리 블록)**
     2. **0x1004~0x1007(두 번째 메모리 블록)**
        → **두 번 읽어야 하므로 속도가 느려짐.**
   
3. **반대로, 8바이트 정렬된 주소에 배치되면, 한 번의 메모리 접근으로 데이터를 읽을 수 있음.**
- 즉, **올바른 정렬이 성능 최적화에 매우 중요!**

------

## ✅ **정리 및 최적화 방법**

### 🔹 **1. `alignas(n)`을 사용하여 명시적으로 정렬**

```
cpp복사편집struct alignas(8) Data {
    int a;
    __int64 b;
};
```

- `alignas(8)`을 사용하면, 구조체가 **8바이트 경계에 배치됨**
- CPU가 한 번에 데이터를 읽고 쓰는 것이 가능해져 성능 향상

### 🔹 **2. 멤버 변수 배치를 최적화하여 패딩 최소화**

```
cpp복사편집struct BadExample {
    char a;    // 1바이트
    int b;     // 4바이트 (패딩 3바이트 발생)
    __int64 c; // 8바이트 (패딩 0바이트)
}; // 총 16바이트

struct GoodExample {
    __int64 c; // 8바이트 (패딩 없음)
    int b;     // 4바이트 (패딩 없음)
    char a;    // 1바이트 (패딩 3바이트 발생)
}; // 총 12바이트 (4바이트 절약)
```

- 구조체 멤버를 **큰 크기 → 작은 크기 순서로 정렬하면 패딩이 줄어듦.**

### 🔹 **3. `#pragma pack(n)`을 사용해 강제 패딩 조정**

```
cpp복사편집#pragma pack(push, 1)
struct PackedData {
    char a;
    int b;
    __int64 c;
};
#pragma pack(pop)
```

- 패킹을 사용하면 **패딩을 제거할 수 있지만, CPU가 비정렬 데이터를 읽을 때 성능이 저하될 수 있음.**
- 성능이 중요한 경우 **가능한 한 패킹을 사용하지 않는 것이 좋음.**

------

## 🚀 **최종 정리**

| 개념                 | 설명                                                         |
| -------------------- | ------------------------------------------------------------ |
| **구조체 정렬**      | 가장 큰 멤버의 크기를 기준으로 정렬됨.                       |
| **패딩(Padding)**    | 멤버 변수가 정렬되지 않으면, 중간에 패딩이 추가됨.           |
| **메모리 정렬 미스** | 8바이트 정렬이 필요한 데이터가 4바이트 정렬된 경우, CPU가 두 번 접근해야 함. |
| **성능 저하 원인**   | 잘못된 정렬로 인해 CPU가 데이터를 여러 번 나누어 읽음.       |
| **최적화 방법**      | 1) `alignas(n)` 사용, 2) 멤버 변수 순서 최적화, 3) `#pragma pack(n)` 활용 |

**👉 결론:**

- **정렬이 깨지면 성능이 저하될 수 있음.**
- **정렬을 맞추는 것이 중요하며, 멤버 변수 배치도 신경 써야 함.**
- **최적화를 위해 `alignas`, `pragma pack`, 변수 순서를 활용할 것!** 🚀
