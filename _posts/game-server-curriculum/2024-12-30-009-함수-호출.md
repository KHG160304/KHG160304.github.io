---
title: (9) 함수 호출
excerpt: 함수 호출 방법, 호출 규약 및 동작 원리에 대해서 알아보자.
categories: 
  - 게임서버 과정
permalink: /game-server-curriculum/:title
toc: true
toc_sticky: true
typora-root-url: ../../
---

[toc]

## 함수 호출이란

특정한 목적을 위해 동작하기 위한 코드들을 한 군데에 모아놓은 코드 뭉치이다.
보통 함수를 작성할 때, 보통 작성된 코드들을 기능 별로 분류하여 정리하기 위해서 사용한다. 

## 함수 호출 동작 원리

### x86 32비트 환경

1. 함수 호출할 때 전달한 매개 변수를 스택 메모리에 저장합니다.
   가장 오른쪽의 인자 값에서 왼쪽 인자 값으로 이동하면서 하나 씩 저장합니다.
2. 다음에 실행할 코드의 주소 값인 호출한 함수의 코드가 저장된, 메모리의 주소를 eip 레지스터에 저장합니다.
3. ebp, esp 레지스터를 활용하여 함수를 위한 스택 메모리를 확보합니다.
4. 함수의 코드를 실행합니다.
5. 함수 마지막에 ret 명령어를 실행하여, 함수를 호출한 명령어의 다음 줄에 실행할 명령어 주소를 eip 레지스터에 저장합니다.
6. 호출자의 실행 흐름으로 돌아옵니다.

> cdecl인지 stdcall 규약 인지에 따라서 ret의 동작이 조금 다릅니다. ret 0x0C 는 12byte(0x0C) 크기의 스택 메모리를 정리하고 ret 명령을 수행하라는 뜻 입니다. 

> 피 호출자 함수가 값을 반환할 때 eax 레지스터를 활용합니다.
> eax 레지스터에 반환 값을 저장하고 나서 ret 명령어를 실행하고
> 호출자는 eax에 저장된 반환 값을 활용하게 됩니다.

### 모든 분기에서 return 반환 값을 정확히 작성해야 하는 이유

1. eax에 저장되어있던 쓰레기 값을 피 호출자가 사용할 경우 문제가 된다.
2. 그리고 일단 컴파일이 정상적으로 된다는 것이 문제이다.

~~~cpp
int AAA(int a, int b, int c) 
{
	// a가 10인 경우만 정상적으로 값을 반환합니다.
    // a가 10이 아닌 경우, eax 레지스터에 저장되어 있던 값이 반환 값이 되어버리는 문제가 발생합니다.
    if (a == 10) 
    {
        return a + b + c;
    }
}


~~~

### stdcall 과 cdecl 방식이 혼용되는 이유

1. stdcall 방식이 먼저 등장하여 사용되었습니다.
2. 윈도우 API 중 stdcall 방식을 사용하는 것들이 존재합니다.
3. 예전에 개발된 함수들과의 호환성을 위해서, stdcall 방식과 cdecl 방식을 혼용해서 사용하게 되었습니다.



## 함수 호출 규약

| 함수 호출 규약 | 스택 정리 | 매개 변수 전달                            |
| -------------- | --------- | ----------------------------------------- |
| cdecl          | 호출자    | 오른쪽에서 왼쪽으로                       |
| stdcall        | 피 호출자 | 오른쪽에서 왼쪽으로                       |
| fastcall       | 피 호출자 | 레지스터에 저장된 뒤에 스택에 저장합니다. |
| thiscall       | 피 호출자 | 오른쪽에서 왼쪽으로, `this`는 ecx에 저장  |

## Call by Reference 란?

1. 함수 호출할 때 인자 값으로 메모리의 주소 값을 넘기는 방식입니다.
2. 보통 32비트 시스템에서는 4바이트 보다 큰 데이터를 넘길 때 사용하고 64비트 시스템에서는 8바이트 보다 큰 데이터를 넘길 때 사용합니다.
3. 포인터 변수를 사용합니다.

## Call by Value 란?

1. 함수 호출할 때 인자 값으로 변수에 저장된 값 자체를 넘기는 방식입니다.
2. 인가의 크기가 32비트에서는 4바이트, 64비트에서는 8바이트를 넘지 않을 경우, Call by Value 방식이 성능 면에서 더 좋습니다.



## 재귀 함수

### 재귀 함수를 사용하는 경우

1. 예를 들어 미로를 탐색하는 알고리즘을 구현한다고 하면, 미로의 길을 탐색 중에 막다른 길에 다다랐을 때 다시 이전의 갈림길로 돌아가서 새로운 길로 탐색을 진행해야 하는데 재귀 함수를 활용하면 쉽게 구현할 수 있다. 함수를 재귀적으로 쭉 호출하면서, 스택에 함수 마다의 상태 값을 저장하면서 가다가 딱 막히는 순간에 다다랐을 때, 함수를 return 만하면 다시 이전에 스택에 저장한 상태 값을 복원해서 사용할 수 있다. 그러면 갈림길이 딱 시작되었을 때의 상태가 저장된 스택을 복원하기만 하면, 막다른 길을 되돌아와서 다시 새로운 길을 탐색할 수 있다.
2. for 문은 단 방향을 탐색할 경우 유리합니다.

### 재귀 함수를 두려워하지 말자

1. 이진탐색 트리는 대략 재귀가 4000번 이상 발생한다면 탐색 대상이 되는 데이터가 무지막지하게 큰 것이다.
2. 밸런스 트리라면 2의 4000 승이 호출된다는 말인데, 로직을 잘 짜면 이런 일이 발생하지 않는다.
3. Release 빌드에서는 대략 재귀 함수 9000번까지 호출이 가능했다.
4. 보통 스택 메모리가 1mb 인데, 재귀 함수 호출로 스택 메모리 1mb를 다 쓰는 것은 로직을 잘못 짜지 않는 이상 발생할 일이 없다.
5. 정말 얼토당토 안하는 경우는 컴파일러가 경고를 띄워준다.
6. c++ 표준 라이브러리에 퀵소트 함수도 재귀 함수로 구현되어 있다.



## 함수 내부에서 예외 처리하는 경우

- 장점
  1. 소스의 가독성이 좋습니다. 함수 안에서 모두 파악이 됩니다.
  2. 유지 보수 및 안정성 측면에서 좋습니다. 관리도 용이 합니다.
- 단점
  1. 성능이 떨어지는 경우가 발생할 수 있습니다. 함수 호출을 할 필요가 없는 상황에서도 함수를 호출해야 하기에 불필요하게 스택 메모리를 생성하는 코드가 삽입됩니다.

## 함수 포인터 변수

- 함수의 주소 값을 저장할 수 있는 포인터 변수입니다.
- int (*ptr)(int, int); ptr이라는 함수 포인터 변수는 integer 파라미터 2개를 넘겨받고 integer 값을 반환하는 함수의 주소 값을 저장할 수 있습니다.
- ptr(1, 1); 이렇게 호출해서 사용하면 된다.

### 함수 포인터 변수의 활용법

1. 함수 포인터 배열을 look up 테이블로 활용 가능합니다. 배열에 특정 인덱스 값을 입력하면, 특정 함수가 바로 호출되게 사용할 수 있습니다.
2. callback 함수를 활용하는 곳에 사용할 수 있습니다.



## IP 레지스터가 오염될 수 있는 상황

피 호출자 함수의 로직에서 호출자의 스택 메모리를 잘못 건드려서, 백업되어있던 (피 호출자 반환 이후에 실행될 명령어의) 주소 값을 변조하는 상황입니다.

### 주소 값의 변조가 미치는 영향

1. 기대하지 않은 이상한 코드가 실행될 수 있습니다.

   > 바이러스, 크래킹, 멀웨어 등등

2. 실행이 불가능한 메모리 영역인 경우, 크래시 발생, 프로그램이 곧바로 정지됩니다.

3. 실행을 기대하지 않은 프로그램의 다른 내부 함수가 실행되면서 데이터를 엉망으로 변조하는 등, 예상하기 어려운 2차, 3차 피해가 발생, 어디서 문제가 발생했는지 원인 파악이 매우 어려워, 시간이 얼마나 걸릴지 예상하기 어렵습니다.

### IP 레지스터 오염 문제 디버깅 과정

1. 피 호출자 `C 함수` 반환으로 인해서 실행 흐름이 호출자 `B 함수`로 바뀌려는 순간 바로 크래시가 발생합니다. 
2. 크래시가 발생했을 때 esp 레지스터를 활용해서, 스택 메모리를 확인합니다.
3. esp가 가리키는 스택 메모리 주소 바로 위에 4byte 또는 8byte 메모리 공간에 저장된 값이 코드 영역의 메모리 주소가 아닌 경우, eip 레지스터가 오염된 것으로 판단 가능합니다.
4. 다시 esp 가 가리키는 스택 메모리 위치로 찾아가서, 메모리를 아래쪽으로 쭉 훑어보면서 코드 영역의 주소일 것 같은 값을 찾습니다.
5. 코드 영역의 주소를 발견하면, 해당 주소 값을 `B 함수`를 호출한   `A 함수` 명령어가 저장된 위치로 가정하고 이동해서 확인합니다.
6. 이동한 주소 바로 위의 주소에 저장된 명령어가 `B함수`를 호출하는 명령어인 경우, <u>이제 스택 메모리 만을 살펴봐서 `B 함수` 가 누구인지 특정해냈습니다.</u>
7. 이 이후에는 `B 함수` 내부에서 호출한 함수 중에 어떤 함수에서 문제가 발생했는지 확인해야 합니다.

> **B 함수는 잦은 빈도로 1초에 수천번 호출되는 함수인가?**

1초에 수천번 호출되는 함수의 로그를 파일에 남기는 것은 그 양을 감당하기 매우 어렵습니다.

> **그래서 메모리에 로그를 남겨야 합니다.**

### IP 레지스터 오염 문제 디버깅 과정2

1. **`B 함수`**가 호출하는 모든 (피 호출자)함수 내부의 첫 라인에서, 피 호출자 함수 스택 영역 바로 아래에 backup된 **`B 함수`**의 코드 영역 주소(backup_B)를 피 호출자 함수의 스택 영역에 복사(backup_C)합니다.

   > B 함수 스택에 저장된 코드 영역 주소 값을 backup_B, 피 호출자 함수 스택에 저장된 코드 영역 주소 값을 backup_C 라고 부르겠습니다.

2. 피 호출자의 로직 중에 의심이 가는 모든 로직의 바로 아래에서 backup_B 와 backup_C의 값을 비교합니다.

3. 문제 상황이 재현되기 전까지는 함수의 로직을 함부로 수정하지 않습니다.

### IP 레지스터의 오염이 주는 어려움

1. 스택 메모리를 분석해서 흔적을 찾는 것은 힘들고 수고스러운 일이며, 시간이 얼마나 걸릴지도 알 수 없습니다.
2. 함수 콜 스택이 손상된 경우 디버깅이 어렵다.
3. 재현이 힘든 경우, 원인을 찾기 매우 어렵다.
