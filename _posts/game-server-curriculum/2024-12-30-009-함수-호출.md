---
title: (9) 함수 호출
excerpt: 함수 호출 방법, 호출 규약 및 동작 원리에 대해서 알아보자.
categories: 
  - 게임서버 과정
permalink: /game-server-curriculum/:title
toc: true
toc_sticky: true
typora-root-url: ../../
---

[toc]

## 함수 호출이란

특정한 목적을 위해 동작하기 위한 코드들을 한 군데에 모아놓은 코드 뭉치이다.
보통 함수를 작성할 때, 보통 작성된 코드들을 기능 별로 분류하여 정리하기 위해서 사용한다. 

## 함수 호출 동작 원리

### x86 32비트 환경

1. 함수 호출할 때 전달한 매개 변수를 스택 메모리에 저장합니다.
   가장 오른쪽의 인자 값에서 왼쪽 인자 값으로 이동하면서 하나 씩 저장합니다.
2. 다음에 실행할 코드의 주소 값인 호출한 함수의 코드가 저장된, 메모리의 주소를 eip 레지스터에 저장합니다.
3. ebp, esp 레지스터를 활용하여 함수를 위한 스택 메모리를 확보합니다.
4. 함수의 코드를 실행합니다.
5. 함수 마지막에 ret 명령어를 실행하여, 함수를 호출한 명령어의 다음 줄에 실행할 명령어 주소를 eip 레지스터에 저장합니다.
6. 호출자의 실행 흐름으로 돌아옵니다.

> cdecl인지 stdcall 규약 인지에 따라서 ret의 동작이 조금 다릅니다. ret 0x0C 는 12byte(0x0C) 크기의 스택 메모리를 정리하고 ret 명령을 수행하라는 뜻 입니다. 

## 함수 호출 규약

| 함수 호출 규약 | 스택 정리 | 매개 변수 전달                            |
| -------------- | --------- | ----------------------------------------- |
| cdecl          | 호출자    | 오른쪽에서 왼쪽으로                       |
| stdcall        | 피 호출자 | 오른쪽에서 왼쪽으로                       |
| fastcall       | 피 호출자 | 레지스터에 저장된 뒤에 스택에 저장합니다. |
| thiscall       | 피 호출자 | 오른쪽에서 왼쪽으로, `this`는 ecx에 저장  |

## IP 레지스터가 오염될 수 있는 상황

피 호출자 함수의 로직에서 호출자의 스택 메모리를 잘못 건드려서, 백업되어있던 (피 호출자 반환 이후에 실행될 명령어의) 주소 값을 변조하는 상황입니다.

### 주소 값의 변조가 미치는 영향

1. 기대하지 않은 이상한 코드가 실행될 수 있습니다.

   > 바이러스, 크래킹, 멀웨어 등등

2. 실행이 불가능한 메모리 영역인 경우, 크래시 발생, 프로그램이 곧바로 정지됩니다.

3. 실행을 기대하지 않은 프로그램의 다른 내부 함수가 실행되면서 데이터를 엉망으로 변조하는 등, 예상하기 어려운 2차, 3차 피해가 발생, 어디서 문제가 발생했는지 원인 파악이 매우 어려워, 시간이 얼마나 걸릴지 예상하기 어렵습니다.

### IP 레지스터 오염 문제 디버깅 과정

1. 피 호출자 `C 함수` 반환으로 인해서 실행 흐름이 호출자 `B 함수`로 바뀌려는 순간 바로 크래시가 발생합니다. 
2. 크래시가 발생했을 때 esp 레지스터를 활용해서, 스택 메모리를 확인합니다.
3. esp가 가리키는 스택 메모리 주소 바로 위에 4byte 또는 8byte 메모리 공간에 저장된 값이 코드 영역의 메모리 주소가 아닌 경우, eip 레지스터가 오염된 것으로 판단 가능합니다.
4. 다시 esp 가 가리키는 스택 메모리 위치로 찾아가서, 메모리를 아래쪽으로 쭉 훑어보면서 코드 영역의 주소일 것 같은 값을 찾습니다.
5. 코드 영역의 주소를 발견하면, 해당 주소 값을 `B 함수`를 호출한   `A 함수` 명령어가 저장된 위치로 가정하고 이동해서 확인합니다.
6. 이동한 주소 바로 위의 주소에 저장된 명령어가 `B함수`를 호출하는 명령어인 경우, <u>이제 스택 메모리 만을 살펴봐서 `B 함수` 가 누구인지 특정해냈습니다.</u>
7. 이 이후에는 `B 함수` 내부에서 호출한 함수 중에 어떤 함수에서 문제가 발생했는지 확인해야 합니다.

> **B 함수는 잦은 빈도로 1초에 수천번 호출되는 함수인가?**

1초에 수천번 호출되는 함수의 로그를 파일에 남기는 것은 그 양을 감당하기 매우 어렵습니다.

> **그래서 메모리에 로그를 남겨야 합니다.**

### IP 레지스터 오염 문제 디버깅 과정2

1. **`B 함수`**가 호출하는 모든 (피 호출자)함수 내부의 첫 라인에서, 피 호출자 함수 스택 영역 바로 아래에 backup된 **`B 함수`**의 코드 영역 주소(backup_B)를 피 호출자 함수의 스택 영역에 복사(backup_C)합니다.

   > B 함수 스택에 저장된 코드 영역 주소 값을 backup_B, 피 호출자 함수 스택에 저장된 코드 영역 주소 값을 backup_C 라고 부르겠습니다.

2. 피 호출자의 로직 중에 의심이 가는 모든 로직의 바로 아래에서 backup_B 와 backup_C의 값을 비교합니다.

3. 문제 상황이 재현되기 전까지는 함수의 로직을 함부로 수정하지 않습니다.

### IP 레지스터의 오염이 주는 어려움

1. 스택 메모리를 분석해서 흔적을 찾는 것은 힘들고 수고스러운 일이다. 시간이 얼마나 걸릴지도 알 수 없다.
2. 
