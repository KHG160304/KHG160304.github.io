---
title: (16) 구조체
excerpt: 구조체의 메모리 배치, 어셈블리 코드로 살펴보자!
categories: 
  - 게임서버 과정
permalink: /game-server-curriculum/:title
toc: true
toc_sticky: true
typora-root-url: ../../
---

## 1️⃣ 구조체란? 🤔

C/C++에서 구조체(struct) 는 여러 개의 변수를 하나로 묶어 관리할 수 있는 사용자 정의 자료형입니다. 일반적으로, 비슷한 속성을 가진 데이터를 함께 다룰 때 사용됩니다.

### 📌 구조체의 특징

1. 여러 변수를 하나로 묶어 관리할 수 있는 **사용자 정의 자료형**입니다.
2. **서로 다른 자료형**의 변수를 하나의 단위로 묶어 사용할 수 있습니다.
3. 구조체 내부에 **또 다른 구조체**를 포함할 수 있습니다.

### 📝 구조체 예제 코드

~~~cpp
struct stData {
    int a;
    int b;
    int c;
    int d;
};

int main(void) {
    stData data;
    data.a = 10;
    data.b = 1;
    data.c = 10;
    data.d = 11;
}
~~~

위 코드를 보면, stData 구조체는 4개의 정수형 변수 (a, b, c, d)를 포함하고 있습니다. 그렇다면 메모리에서는 어떻게 저장될까요? 이를 확인하기 위해 어셈블리 코드를 분석해보겠습니다.



---



## 2️⃣ 구조체의 메모리 배치, 어셈블리 코드 분석 🔍

~~~cpp
push ebp
mov ebp, esp
sub esp, 10h	; 구조체 크기만큼(16바이트) 스택 공간 할당
    
mov dword ptr[ebp-10h], 10 	; data.a = 10
mov dword ptr[ebp-0Ch], 1	; data.b = 1
mov dword ptr[ebp-08h], 10	; data.c = 10
mov dword ptr[ebp-04h], 11	; data.d = 11
~~~

1. `sub esp, 10`: 구조체 크기만큼(16바이트) 스택 공간을 확보합니다.
2. `mov dword ptr[ebp-10h], 10`: 구조체의 첫 번째 멤버(a)에 값을 저장합니다.
3. 나머지 멤버들로 차례대로 메모리에 저장됩니다.

📌 **결론**: 구조체는 단순히 연속된 메모리 공간일 뿐, 개별 변수와 다를 바가 없습니다.



---



## 3️⃣ 포인터 변수로 구조체에 접근하기

구조체의 포인터 변수로 메모리 접근을 할 때는 약간의 차이가 있습니다.

~~~cpp
struct stData {
    int a;
    int b;
    int c;
    int d;
};

int main(void) {
    stData data;
    data.a = 10;
    data.b = 1;
    data.c = 10;
    data.d = 11;
    
    stData* ptr = &data;
    ptr->a = 12;
    ptr->b = 10;
    ptr->c = 11;
    ptr->d = 14;
}
~~~

포인터를 통해서 data에서 각각 구조체 멤버의 메모리에 접근할 때 `->` 연산자를 활용하여 접근하는 모습을 확인할 수 있습니다.



### 어셈블리 코드 분석 🔍

~~~cpp
mov eax, dword ptr[ebp-18h]	; ptr을 eax에 로드합니다. (구조체의 시작 주소)
mov dword ptr[eax], 0Ch		; 
mov dword ptr[eax+4], 0Ah
mov dword ptr[eax+8], 0Bh
mov dword ptr[eax+0Ch], 0Eh
~~~

1. 구조체의 시작 주소를 eax에 로드합니다.
2. eax에 저장된 시작 주소를 기준으로 각 멤버의 메모리 주소를 계산하여 값을 저장합니다.
   - `eax`에는 구조체의 시작 주소가 저장되어 있으므로, 구조체 멤버에 접근하기 위해 `eax`를 기준으로 오프셋을 계산합니다.
   - `mov dword ptr[eax], 0Ch`는 `eax`가 가리키는 주소에 있는 `a` 멤버에 `0x0C`를 저장하는 명령입니다. 이와 같은 방식으로 다른 멤버들도 각각의 오프셋(`eax+4`, `eax+8`, `eax+0Ch`)을 통해 값을 저장합니다.

### 포인터를 통한 구조체 접근 시 특징 🔍

1. 구조체의 시작 주소와 첫 번째 멤버의 메모리 주소가 동일하여, 첫 번째 요소에 접근이 성능상 가장 빠릅니다.
   - 구조체의 첫 번째 멤버에 접근할 때는 추가적인 오프셋 계산이 필요 없으므로 성능상 유리합니다.
2. 어셈블리 코드만 보고 구조체임을 식별할 수 있습니다.
   - 포인터를 사용한 구조체 접근 방식은 어셈블리 코드에서 그 특성이 분명히 드러납니다. 예를 들어, eax 레지스터에 구조체의 시작 주소를 로드한 후, 각 멤버에 오프셋을 더하여 접근하는 방식은 구조체에만 해당되는 특징입니다.

### 구조체를 사용할 때 도움이 되는 팁

1. 구조체 멤버 중 빈번하게 접근할 요소는 첫 번째 멤버로 정의하자

   - 구조체의 첫 번째 멤버는 구조체의 시작 주소에 위치하므로, 추가적인 오프셋 계산 없이 바로 참조할 수 있습니다. 반면, 나머지 요소는 구조체 시작 주소를 기준으로 오프셋을 더해 참조해야 하므로 상대적으로 접근이 더 복잡합니다.

2. 구조체 멤버의 메모리 순서는 보장된다.

   - 데이터를 메모리에 원하는 순서대로 나열하고 싶다. 이때 구조체를 활용하면 최적화 컴파일을 하더라도 메모리상에 정렬된 데이터의 순서는 구조체 멤버를 정의한 순서와 같습니다.

   > 순서 보장의 장점으로 메모리 접근 패턴 예측으로 인한 캐시 최적화, 직렬화 역직렬화 작업 효율성, 메모리 사용 최적화, 코드 가독성 유지보수 향상, 다양한 시스템에서 데이터의 일관성과 안정성을 보장하여 서로 다른 시스템 간에 호환성과 상호 운용성을 쉽게 유지(네트워크 통신 또는 데이터 전송 시 일관된 결과 보장)가 있습니다.



