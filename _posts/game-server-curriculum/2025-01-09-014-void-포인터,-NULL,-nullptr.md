---
title: (14) void 포인터, NULL, nullptr
excerpt: void 포인터, NULL, nullptr에 대해서 알아보자
categories: 
  - 게임서버 과정
permalink: /game-server-curriculum/:title
toc: true
toc_sticky: true
typora-root-url: ../../
---



## void*의 특징

1. **모든 자료형의 주소 값을 저장할 수 있습니다.**
   **`void*`** 는 특정 데이터 타입에 의존하지 않으므로, 어떤 자료형의 주소값도 저장할 수 있습니다. 이는 **`void*`**가 메모리 주소만 다루기 때문입니다.
2. **자료형이 지정되지 않았음을 의미합니다.**
   **`void`**는 "자료형이 없음"을 나타내는 키워드로, **`void*`**는 어떤 특정 타입을 가리키는 것이 아니라, 단지 주소값을 나타내기 위해 사용됩니다.
3. **크기가 정의되지 않습니다.**
   **`void`**는 크기와 관련된 개념이 없으므로, **`void*`** 자체의 크기도 정의할 수 없습니다. 이는 **`void`**가 특정 자료형을 가지지 않기 때문입니다.
4. **연산이 불가능합니다.**
   **`void*`**는 자료형의 크기를 알 수 없기 때문에, **`+`**, **`-`**, **`*`**(역참조) 와 같은 연산을 수행할 수 없습니다. 또한 `void* ptr; ptr[0] = 10;`과 같은 방식으로 배열 인덱싱을 할 수 없습니다. 이를 위해서는 **`void*`**를 특정 자료형으로 형변환해야 합니다.

### void* 활용

1. **주소값 비교용**
   **`void*`**는 특정 타입에 종속되지 않으므로, 포인터 간의 주소값 비교를 할 때 유용하게 사용할 수 있습니다. 이 경우, **`void*`**는 실제 데이터 타입을 알 필요 없이 단순히 메모리 주소를 비교하는 데 사용됩니다.
2. **로그에 주소값 기록용**
   **`void*`** 포인터는 특정 데이터 타입을 갖지 않기 때문에, 로그에서 메모리 주소를 기록할 때 타입에 구애받지 않고 사용할 수 있습니다. 이렇게 기록된 주소값은 나중에 디버깅 시 유용하게 사용될 수 있습니다.

## NULL 이란

1. 포인터가 어떤 유효한 메모리 주소도 가리키지 않고 있음을 나타내는 상수입니다.

   > 아무것도 가리키지 않는다. 는 의미입니다.

2. 유효하지 않은 메모리 주소를 가리키는 것을 방지하는 용도로 활용됩니다.

3. 보통 값 0을 정의한 매크로 입니다.

1.  포인터 변수에 NULL을 대입하면 "이 포인터 변수는 유효하지 않습니다." 라는 의미입니다.

## C++ 에서 nullptr 키워드

1. 이 포인터는 유효하지 않은 주소를 가리키고 있습니다. 라는 명확한 의미를 전달하는데 사용합니다.

2. 타입 안전성을 제공합니다. C 에서 NULL은 0으로 정의되며, int형 값이기 때문에 포인터 이외의 정수형 변수에 사용하면 타입이 모호해질 수 있다는 단점이 있는데, 포인터 이외의 타입에 nullptr 키워드를 대입하려 하면 컴파일 오류가 발생합니다. 

   > 타입이 모호해질 수 있다의 의미는?
   >
   > **다른 사람이 코드를 읽을 때 `NULL`이 정수형 `0`으로 처리될 것이라고 오해할 수 있다는 문제**가 발생할 수 있습니다.

3. 함수 오버로딩 시 NULL을 처리하는 방식에서 혼동이 발생할 수 있는 상황을 방지하고 오버로딩을 명확하게 합니다.
   ~~~cpp
   void func(int);       // int형을 받는 함수
   void func(char*);     // 포인터형을 받는 함수
   
   func(NULL);           // 함수가 모호해질 수 있음
   func(nullptr);        // 명확히 char*형 함수 호출
   ~~~

4. C++ 11에서 도입된 키워드로, C++11 이하에서는 사용할 수 없습니다.
